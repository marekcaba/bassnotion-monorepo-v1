# Domain-Driven Design Strategy for BassNotion

## Introduction

This document outlines a comprehensive Domain-Driven Design (DDD) strategy for the BassNotion platform. It extends beyond the basic domain-based folder structure to include strategic and tactical DDD patterns, ensuring a robust foundation for the platform's development. This strategy aims to align technical implementation with business goals while maintaining clear boundaries between different parts of the system.

## Strategic Design

### Ubiquitous Language

A shared language between developers and domain experts is essential for effective communication and system design. Below is the core ubiquitous language for BassNotion:

| Term                           | Definition                                                                                 | Context    |
| ------------------------------ | ------------------------------------------------------------------------------------------ | ---------- |
| Widget                         | A self-contained module providing specific bass learning functionality                     | Core       |
| Individual Practice Widget     | Specialized widget that can function standalone or within Bass Drills composite           | Core       |
| Bass Drills Composite Widget   | Central container that integrates individual practice widgets into unified experience      | Core       |
| Sheet Player                   | Shared visualization component for displaying music notation, tabs, and chord symbols      | Shared UI  |
| Fretboard Visualizer           | Shared visualization component for displaying fretboard positions and fingerings          | Shared UI  |
| Connection Widget              | Widget for training fretboard navigation and position transitions                         | Core       |
| Rhythm Widget                  | Widget for rhythm training with customizable drummer module and advanced metronome        | Core       |
| Recording Widget               | Widget for capturing user performances with real-time waveform display                    | Core       |
| Articulation Widget            | Widget for technique training (hammer-ons, pull-offs, bends, ghost notes)                | Core       |
| Lick Widget                    | Widget for practicing iconic bass licks with curated library                             | Core       |
| Harmony Widget                 | Widget for hands-on music theory training via interactive fretboard and notation         | Core       |
| Technique Widget               | Widget for systematic left and right-hand technique development                           | Core       |
| Imitation Widget               | Widget for call-and-response ear training and stylistic development                       | Core       |
| YouTube Exerciser Widget (YTE) | Widget that processes YouTube links and orchestrates configuration of other widgets       | Core       |
| Core Playback Engine           | Foundational shared service providing audio playback across all widgets                   | Core       |
| Main Story Arc                 | A complete learning journey with progressive difficulty                                    | Learning   |
| Main Quest                     | A major section within a Story Arc representing a significant learning milestone           | Learning   |
| Stage                          | A subdivision of a Main Quest focusing on specific skills or concepts                      | Learning   |
| Mission                        | A structured learning objective within a Stage with multiple tasks                         | Learning   |
| ZERO Mission                   | Mandatory initial assessment mission for all users to determine skill level                | Learning   |
| Task                           | An individual activity within a Mission (exercise, recording, quiz, etc.)                  | Learning   |
| Drummer Loops                  | Customizable rhythm patterns provided by Core Playback Engine                             | Core       |
| Groove Card                    | A specific type of exercise with associated metadata                                       | Content    |
| MIDI Extraction                | The process of converting audio to MIDI notation via external API                          | Analysis   |
| Generation Token               | Unit of YouTube link processing that delivers exercises from tutorials                     | Core       |
| Badge                          | Achievement award for practice streaks, exercise scores, or completing groove cards        | User       |
| Neck Diagram                   | Visual representation of bass fretboard showing finger positions                           | Content    |
| User Progress                  | A record of a user's advancement through the platform                                      | User       |
| Skill Level                    | Classification of user proficiency (beginner, intermediate, advanced)                      | Assessment |

### Bounded Contexts

The BassNotion platform is divided into the following bounded contexts:

1. **User Context**

   - Responsible for user management, authentication, and profiles
   - Contains user preferences, settings, and personal data
   - Manages badges, achievements, and practice streaks
   - Interfaces with authentication providers
   - Tracks token balance and purchases

2. **Learning Context**

   - Manages the hierarchical learning system (Story Arcs, Quests, Stages, Missions, Tasks)
   - Handles skill assessment and level determination
   - Tracks user progress through learning content
   - Manages generation token usage and allocation

3. **Content Context**

   - Manages exercise library, groove cards, and practice materials
   - Handles content categorization, tagging, and discovery
   - Provides content recommendations based on user level
   - Manages neck diagrams and visual representations

4. **Widget Context**

   - Contains Bass Drills Composite Widget and all individual practice widget implementations
   - Individual widgets: Connection, Rhythm, Recording, Articulation, Lick, Harmony, Technique, Imitation
   - Manages composite widget pattern where individual widgets can function standalone or within Bass Drills
   - Consumes shared visualization components (Sheet Player, Fretboard Visualizer)
   - Manages widget configuration and state
   - Provides the framework for widget communication and integration

5. **Shared UI Context**

   - Houses shared visualization components
   - Provides consistent music notation and fretboard display
   - Maintains visualization state and synchronization
   - Interfaces with Playback Context for audio sync

6. **Playback Context**

   - Manages the Core Playback Engine as foundational shared service
   - Handles metronome, drummer loops, and reference audio playback
   - Controls tempo and pitch adjustments
   - Provides unified audio playback services to all individual practice widgets
   - Serves as the audio foundation for the entire platform

7. **Analysis Context**

   - Handles integration with external audio processing and MIDI extraction
   - Processes YouTube videos via the YouTube Exerciser Widget
   - Orchestrates analysis workflows through n8n
   - Provides feedback on user performances

8. **Social Context** (Future)
   - Will manage user interactions, sharing, and community features
   - Will handle content ratings, comments, and social engagement
   - Will provide teacher-student relationships and mentoring

### Context Map

The following context map illustrates the relationships between bounded contexts:

```
                                  ┌─────────────────┐
                                  │                 │
                                  │  User Context   │
                                  │                 │
                                  └────────┬────────┘
                                           │
                                           │ Conformist
                                           ▼
┌─────────────────┐  Customer/Supplier  ┌─────────────────┐  Partnership  ┌─────────────────┐
│                 │◄────────────────────┤                 ├───────────────►                 │
│ Content Context │                     │ Learning Context│                │ Widget Context  │
│                 ├────────────────────►│                 │◄───────────────┤                 │
└────────┬────────┘  Customer/Supplier  └────────┬────────┘  Partnership  └────────┬────────┘
         │                                       │                                 │
         │                                       │                                 │
         │ Open Host                             │ Partnership                     │ Partnership
         │ Service                               │                                 │
         ▼                                       ▼                                 ▼
┌─────────────────┐                     ┌─────────────────┐               ┌─────────────────┐
│                 │                     │                 │               │                 │
│ Social Context  │                     │ Analysis Context│               │ Shared UI       │
│    (Future)     │                     │                 │               │   Context       │
└─────────────────┘                     └────────┬────────┘               └────────┬────────┘
                                                 │                                 │
                                                 │ Customer/Supplier               │ Shared Kernel
                                                 ▼                                 ▼
                                        ┌─────────────────┐               ┌─────────────────┐
                                        │                 │               │                 │
                                        │ External APIs   │               │ All Widgets     │
                                        │  (n8n, YouTube) │               │                 │
                                        └─────────────────┘               └─────────────────┘
```

### Context Relationships

1. **User Context → Learning Context (Conformist)**

   - Learning Context conforms to the user model defined by User Context
   - User Context provides authentication and profile information
   - Badge achievements flow from Learning Context to User Context

2. **Content Context ↔ Learning Context (Customer/Supplier)**

   - Learning Context consumes content from Content Context
   - Content Context adapts to meet Learning Context requirements
   - Neck diagrams and visual aids are provided by Content Context

3. **Widget Context ↔ Learning Context (Partnership)**

   - Learning Context provides generation tokens to Widget Context
   - Widget Context provides exercise completion data to Learning Context

4. **Widget Context ↔ Playback Context (Partnership)**

   - Playback Context provides audio services to Widget Context
   - Widget Context provides configuration and control to Playback Context
   - YouTube Exerciser Widget configures Playback Context based on exercises

5. **Playback Context → All Widgets (Shared Kernel)**

   - Playback engine is a shared kernel used by all widgets
   - Consistent audio playback interface across the platform
   - Metronome, drummer loops, and reference MIDI basslines available to all widgets

6. **Analysis Context → External APIs (Customer/Supplier)**

   - Analysis Context consumes external services (n8n, YouTube)
   - Adapts to external API requirements and orchestrates workflows
   - Processes YouTube links and returns exercise data

7. **Content Context → Social Context (Open Host Service)**

   - Content Context provides a public API for Social Context
   - Social Context consumes content without tight coupling

8. **Learning Context ↔ Analysis Context (Partnership)**
   - Collaborative relationship for performance assessment
   - Shared responsibility for user feedback
   - Analysis Context provides exercise data for Learning Context

9. **Widget Context ↔ Shared UI Context (Shared Kernel + Consumer/Supplier)**

   - Primary relationship is Shared Kernel for visualization components
   - Widget Context is the primary consumer of Sheet Player and Fretboard Visualizer
   - Shared UI Context maintains component lifecycle and state management
   - Key interactions:
     - Widgets consume visualization components through well-defined interfaces
     - Shared UI Context handles rendering, updates, and synchronization
     - Widget Context provides configuration and data to components
     - Both contexts share common types and interfaces for music visualization
   - Responsibilities:
     - Shared UI Context:
       - Core visualization logic and rendering
       - Component lifecycle management
       - Theme and style consistency
       - Performance optimization
       - Cross-widget state synchronization
     - Widget Context:
       - Widget-specific configuration of visualization components
       - Data provision for visualization
       - Integration with Playback Context for timing
       - User interaction handling
   - This relationship ensures:
     - Consistent visualization across all widgets
     - Centralized performance optimization
     - Reduced code duplication
     - Clear separation of concerns

### Anti-Corruption Layers

To maintain context boundaries and prevent concept leakage, the following anti-corruption layers are implemented:

1. **YouTube Exerciser ACL**

   - Location: Between Analysis Context and External APIs
   - Purpose: Isolate YouTube API specifics and n8n orchestration from the rest of the system
   - Implementation: Adapter pattern translating external concepts to internal models
   - Handles generation token validation and consumption

2. **MIDI Extraction ACL**

   - Location: Between Analysis Context and External APIs
   - Purpose: Isolate external MIDI extraction services
   - Implementation: Facade pattern with domain-specific translation services

3. **Playback Engine ACL**

   - Location: Between Playback Context and Widget Context
   - Purpose: Provide consistent interface for audio playback across widgets
   - Implementation: Facade pattern with standardized playback controls

4. **Authentication ACL**

   - Location: Between User Context and external auth providers
   - Purpose: Isolate authentication implementation details
   - Implementation: Adapter pattern with standardized user model

5. **Badge System ACL**
   - Location: Between User Context and Learning Context
   - Purpose: Standardize achievement tracking and badge awarding
   - Implementation: Mediator pattern for badge criteria evaluation

6. **Widget Visualization ACL**

   - Location: Between Widget Context and Shared UI Context
   - Purpose: Standardize interaction with shared visualization components
   - Implementation: Adapter pattern with specialized hooks and utilities
   - Key features:
     - Type-safe component props
     - Standardized configuration interfaces
     - Common event handling patterns
     - Shared state management utilities

## Tactical Design

### Aggregates

Aggregates define transactional boundaries and consistency rules. Key aggregates in BassNotion include:

1. **User Aggregate (User Context)**

   - Root: User
   - Entities: UserProfile, UserPreferences, BadgeCollection
   - Value Objects: Email, Password, SkillLevel
   - Invariants: Email must be unique, password must meet security requirements

2. **Learning Path Aggregate (Learning Context)**

   - Root: MainStoryArc
   - Entities: MainQuest, Stage, Mission, Task
   - Value Objects: Difficulty, LearningObjective
   - Invariants: Hierarchical structure must be maintained, missions must belong to stages

3. **Mission Aggregate (Learning Context)**

   - Root: Mission
   - Entities: Task, MissionReward
   - Value Objects: TaskCompletion, MissionStatus
   - Invariants: Tasks must be completed in order, mission status depends on task completion

4. **Exercise Aggregate (Content Context)**

   - Root: Exercise
   - Entities: ExerciseVariation, NeckDiagram
   - Value Objects: Difficulty, ExerciseType, Tags
   - Invariants: Exercise must have valid difficulty and type

5. **YouTube Exerciser Aggregate (Widget Context)**

   - Root: YouTubeExerciserWidget
   - Entities: ExerciseList, VideoEmbed, TimestampMarker
   - Value Objects: YouTubeUrl, ExerciseSelection
   - Invariants: URL must be valid, exercises must be associated with timestamps

6. **Bass Drills Widget Aggregate (Widget Context)**

   - Root: BassDrillsWidget
   - Entities: WidgetReference, DrillConfiguration
   - Value Objects: DrillType, DrillStatus
   - Invariants: Must reference valid widgets, configuration must be consistent

7. **Playback Engine Aggregate (Playback Context)**

   - Root: PlaybackEngine
   - Entities: AudioTrack, MetronomeSettings, DrummerLoop
   - Value Objects: Tempo, Pitch, Volume
   - Invariants: Tempo and pitch must be within valid ranges

8. **Generation Token Aggregate (Learning Context)**

   - Root: GenerationToken
   - Entities: TokenUsage, TokenAllocation
   - Value Objects: TokenType, TokenStatus
   - Invariants: Token usage must not exceed allocation

9. **Badge Aggregate (User Context)**
   - Root: BadgeCollection
   - Entities: Badge, BadgeProgress
   - Value Objects: BadgeType, AchievementCriteria
   - Invariants: Badge awarding must follow defined criteria

10. **Sheet Player Aggregate (Shared UI Context)**
    - Root: SheetPlayer
    - Entities: NotationDisplay, ChordDisplay, TabDisplay
    - Value Objects: NotationData, DisplaySettings
    - Invariants: Valid notation data format, consistent display settings

11. **Fretboard Visualizer Aggregate (Shared UI Context)**
    - Root: FretboardVisualizer
    - Entities: FretboardDisplay, PositionMarker
    - Value Objects: FretboardConfig, PositionData
    - Invariants: Valid fretboard configuration, consistent position data

### Entities

Entities have identity that persists across state changes. Key entities include:

1. **User**

   - Identity: userId (UUID)
   - Lifecycle: Created on registration, never deleted (only deactivated)
   - Relationships: Has UserProfile, UserProgress, UserPreferences, BadgeCollection

2. **MainStoryArc**

   - Identity: arcId (UUID)
   - Lifecycle: Created by admin, contains MainQuests
   - Relationships: Contains MainQuests, associated with SkillLevel

3. **MainQuest**

   - Identity: questId (UUID)
   - Lifecycle: Created by admin, belongs to MainStoryArc
   - Relationships: Belongs to MainStoryArc, contains Stages

4. **Stage**

   - Identity: stageId (UUID)
   - Lifecycle: Created by admin, belongs to MainQuest
   - Relationships: Belongs to MainQuest, contains Missions

5. **Mission**

   - Identity: missionId (UUID)
   - Lifecycle: Created by admin, belongs to Stage
   - Relationships: Belongs to Stage, contains Tasks

6. **Task**

   - Identity: taskId (UUID)
   - Lifecycle: Created by admin, belongs to Mission
   - Relationships: Belongs to Mission, may reference Widgets or Exercises

7. **YouTubeExerciserWidget**

   - Identity: widgetId (UUID) with type "youtube-exerciser"
   - Lifecycle: Processes YouTube URLs and displays extracted exercises
   - Relationships: Configures other widgets based on selected exercise
   - Components: Video embed, exercise list, neck diagram, timestamp markers, tutorial summary

8. **BassDrillsWidget**

   - Identity: widgetId (UUID) with type "bass-drills"
   - Lifecycle: Central widget that integrates other widgets
   - Relationships: Composes multiple individual widgets

9. **PlaybackEngine**

   - Identity: Single instance with configuration
   - Lifecycle: Created at application startup, persists throughout session
   - Relationships: Used by all widgets requiring audio playback

10. **GenerationToken**

    - Identity: tokenId (UUID)
    - Lifecycle: Created, consumed, potentially replenished
    - Relationships: Associated with User, consumed by YouTubeExerciserWidget

11. **Badge**
    - Identity: badgeId (UUID)
    - Lifecycle: Created by admin, awarded to users
    - Relationships: Belongs to BadgeCollection, associated with achievement criteria

12. **SheetPlayer**
    - Identity: sheetPlayerId (UUID)
    - Lifecycle: Created, used for notation display
    - Relationships: Used by Rhythm and Lick widgets

13. **FretboardVisualizer**
    - Identity: fretboardVisualizerId (UUID)
    - Lifecycle: Created, used for fretboard display
    - Relationships: Used by Connection and Lick widgets

### Value Objects

Value objects are immutable and defined by their attributes. Key value objects include:

1. **SkillLevel**

   - Attributes: level (beginner, intermediate, advanced), points
   - Usage: Classifying user proficiency and content difficulty

2. **ExerciseMetadata**

   - Attributes: difficulty, genre, technique, tempo
   - Usage: Describing exercise characteristics

3. **MissionProgress**

   - Attributes: completedTasks, totalTasks, status
   - Usage: Tracking progress through a mission

4. **WidgetConfiguration**

   - Attributes: settings (JSON), enabled features
   - Usage: Configuring widget behavior

5. **PlaybackSettings**

   - Attributes: tempo, pitch, metronomeEnabled, drummerLoopEnabled
   - Usage: Configuring playback engine behavior

6. **TimestampMarker**

   - Attributes: time (seconds), label, exerciseId
   - Usage: Marking exercise positions in YouTube videos

7. **NeckDiagram**

   - Attributes: positions (array of fret/string positions), fingering
   - Usage: Visualizing bass fretboard positions for exercises

8. **PracticeStreak**

   - Attributes: days, lastPracticeDate
   - Usage: Tracking consecutive days of practice for badges

9. **AnalysisMetrics**
   - Attributes: rhythmAccuracy, pitchAccuracy, tempo
   - Usage: Quantifying performance quality

10. **NotationData**
    - Attributes: data (binary), format
    - Usage: Storing notation data for Sheet Player

11. **DisplaySettings**
    - Attributes: width, height, color scheme
    - Usage: Configuring display settings for Sheet Player

12. **FretboardConfig**
    - Attributes: width, height, tuning
    - Usage: Configuring fretboard display for Fretboard Visualizer

13. **PositionData**
    - Attributes: positions (array of fret/string positions)
    - Usage: Storing position data for Fretboard Visualizer

### Domain Services

Domain services handle operations that don't naturally belong to entities or value objects:

1. **SkillAssessmentService**

   - Purpose: Evaluate user skill level based on assessment results
   - Operations: analyzeAssessment(), determineSkillLevel(), recommendStartingPoint()

2. **YouTubeExerciserService**

   - Purpose: Process YouTube URLs and configure widgets based on selected exercises
   - Operations: processYouTubeUrl(), extractExercises(), configureWidgetsForExercise()

3. **PlaybackEngineService**

   - Purpose: Provide audio playback capabilities across the platform
   - Operations: playMetronome(), playDrummerLoop(), playBassReference(), adjustTempo(), adjustPitch()

4. **ProgressTrackingService**

   - Purpose: Track and update user progress across the learning hierarchy
   - Operations: updateProgress(), calculateXp(), checkLevelUp()

5. **BadgeAwardService**

   - Purpose: Evaluate criteria and award badges to users
   - Operations: evaluatePracticeStreak(), evaluateExerciseScore(), awardBadge()

6. **GenerationTokenService**

   - Purpose: Manage generation token allocation and consumption
   - Operations: allocateTokens(), consumeToken(), checkTokenAvailability()

7. **WidgetCompositionService**

   - Purpose: Manage widget composition in the Bass Drills Widget
   - Operations: composeWidgets(), configureWidgetChain(), synchronizeWidgetStates()

8. **FeedbackGenerationService**
   - Purpose: Generate personalized feedback based on performance
   - Operations: analyzePerfomance(), generateFeedback(), recommendNextSteps()

9. **VisualizationSyncService**
   - Purpose: Synchronize shared visualization components with playback engine
   - Operations: syncWithPlayback(), updateVisualPosition(), handlePlaybackEvents()

10. **NotationRenderService**
    - Purpose: Handle rendering of music notation in Sheet Player
    - Operations: renderNotation(), updateDisplay(), handleZoom()

11. **FretboardRenderService**
    - Purpose: Handle rendering of fretboard diagrams in Fretboard Visualizer
    - Operations: renderFretboard(), updatePositions(), handleInteraction()

### Repositories

Repositories provide access to aggregates and handle persistence concerns:

1. **UserRepository**

   - Purpose: Access and persist User aggregates
   - Methods: findById(), findByEmail(), save(), update()

2. **BadgeRepository**

   - Purpose: Access and persist Badge aggregates
   - Methods: findById(), findByUser(), findByType(), save(), update()

3. **LearningPathRepository**

   - Purpose: Access and persist MainStoryArc aggregates and their hierarchy
   - Methods: findArcById(), findQuestById(), findStageById(), findMissionById(), save(), update()

4. **MissionRepository**

   - Purpose: Access and persist Mission aggregates
   - Methods: findById(), findByStage(), save(), update()

5. **ExerciseRepository**

   - Purpose: Access and persist Exercise aggregates
   - Methods: findById(), findByTags(), save(), update()

6. **WidgetRepository**

   - Purpose: Access and persist Widget configurations
   - Methods: findByType(), findByUser(), save(), update()

7. **GenerationTokenRepository**

   - Purpose: Access and persist GenerationToken aggregates
   - Methods: findByUser(), findAvailable(), save(), update()

8. **YouTubeExerciserRepository**
   - Purpose: Access and persist YouTube extraction data
   - Methods: findByVideoId(), findByExerciseType(), save(), update()

9. **VisualizationConfigRepository**
   - Purpose: Access and persist visualization component configurations
   - Methods: findByWidget(), findByUser(), save(), update()

10. **NotationDataRepository**
    - Purpose: Access and persist notation data for Sheet Player
    - Methods: findById(), findByExercise(), save(), update()

11. **FretboardDataRepository**
    - Purpose: Access and persist fretboard position data
    - Methods: findById(), findByExercise(), save(), update()

### Domain Events

Domain events capture significant occurrences within the domain:

1. **UserRegisteredEvent**

   - Triggered: When a new user registers
   - Handlers: InitiateAssessmentHandler, WelcomeEmailHandler, TokenAllocationHandler

2. **YouTubeUrlProcessedEvent**

   - Triggered: When a YouTube URL is processed and exercises are extracted
   - Handlers: ExerciseListHandler, TokenConsumptionHandler, RecommendationHandler

3. **ExerciseSelectedEvent**

   - Triggered: When a user selects an exercise from the YouTube Exerciser
   - Handlers: VideoTimestampHandler, WidgetConfigurationHandler, PlaybackConfigurationHandler

4. **MissionCompletedEvent**

   - Triggered: When a user completes all tasks in a mission
   - Handlers: ProgressUpdateHandler, RewardHandler, NextMissionHandler, BadgeEvaluationHandler

5. **StageCompletedEvent**

   - Triggered: When a user completes all missions in a stage
   - Handlers: StageProgressHandler, NextStageHandler, BadgeEvaluationHandler

6. **QuestCompletedEvent**

   - Triggered: When a user completes all stages in a quest
   - Handlers: QuestProgressHandler, NextQuestHandler, BadgeEvaluationHandler

7. **PracticeStreakUpdatedEvent**

   - Triggered: When a user's practice streak changes
   - Handlers: BadgeEvaluationHandler, UserNotificationHandler

8. **BadgeAwardedEvent**

   - Triggered: When a user earns a badge
   - Handlers: UserNotificationHandler, ProfileUpdateHandler

9. **SkillLevelChangedEvent**

   - Triggered: When a user's skill level changes
   - Handlers: ContentRecommendationHandler, UIUpdateHandler, BadgeEvaluationHandler

10. **PerformanceAnalyzedEvent**
    - Triggered: When a user's performance is analyzed
    - Handlers: FeedbackGenerationHandler, ProgressUpdateHandler, BadgeEvaluationHandler

11. **VisualizationSyncEvent**
    - Triggered: When playback position changes
    - Handlers: SheetPlayerSyncHandler, FretboardVisualizerSyncHandler

12. **NotationDisplayEvent**
    - Triggered: When notation display settings change
    - Handlers: NotationRenderHandler, DisplayUpdateHandler

13. **FretboardDisplayEvent**
    - Triggered: When fretboard display settings change
    - Handlers: FretboardRenderHandler, DisplayUpdateHandler

14. **VisualizationInteractionEvent**
    - Triggered: When user interacts with visualization components
    - Handlers: PlaybackSyncHandler, WidgetConfigurationHandler

## Event Storming Results

Event storming sessions identified the following key flows:

### User Registration and Assessment Flow

1. **Command**: RegisterUser
2. **Event**: UserRegisteredEvent
3. **Command**: InitiateAssessment
4. **Event**: AssessmentInitiatedEvent
5. **Command**: SubmitAssessment
6. **Event**: AssessmentCompletedEvent
7. **Command**: DetermineSkillLevel
8. **Event**: SkillLevelDeterminedEvent
9. **Command**: AssignInitialMission
10. **Event**: MissionAssignedEvent
11. **Command**: AllocateGenerationTokens
12. **Event**: TokensAllocatedEvent

### YouTube Exerciser Flow

1. **Command**: SubmitYouTubeUrl
2. **Event**: YouTubeUrlSubmittedEvent
3. **Command**: ConsumeGenerationToken
4. **Event**: TokenConsumedEvent
5. **Command**: SendToN8nOrchestration
6. **Event**: N8nWorkflowTriggeredEvent
7. **Command**: ProcessExtractedData
8. **Event**: ExercisesExtractedEvent
9. **Command**: DisplayExerciseList
10. **Event**: ExerciseListDisplayedEvent
11. **Command**: SelectExercise
12. **Event**: ExerciseSelectedEvent
13. **Command**: JumpToVideoTimestamp
14. **Event**: VideoTimestampChangedEvent
15. **Command**: ConfigureWidgetsForExercise
16. **Event**: WidgetsConfiguredEvent
17. **Command**: ConfigurePlaybackEngine
18. **Event**: PlaybackEngineConfiguredEvent

### Learning Hierarchy Progression Flow

1. **Command**: StartMission
2. **Event**: MissionStartedEvent
3. **Command**: CompleteTask
4. **Event**: TaskCompletedEvent
5. **Command**: CheckMissionCompletion
6. **Event**: MissionCompletedEvent
7. **Command**: CheckStageCompletion
8. **Event**: StageCompletedEvent
9. **Command**: CheckQuestCompletion
10. **Event**: QuestCompletedEvent
11. **Command**: AwardXpAndRewards
12. **Event**: RewardsAwardedEvent
13. **Command**: EvaluateBadgeCriteria
14. **Event**: BadgeAwardedEvent
15. **Command**: DetermineNextMission
16. **Event**: NextMissionAssignedEvent

### Playback Engine Flow

1. **Command**: ConfigurePlaybackEngine
2. **Event**: PlaybackEngineConfiguredEvent
3. **Command**: StartMetronome
4. **Event**: MetronomeStartedEvent
5. **Command**: PlayDrummerLoop
6. **Event**: DrummerLoopPlayingEvent
7. **Command**: AdjustTempo
8. **Event**: TempoChangedEvent
9. **Command**: AdjustPitch
10. **Event**: PitchChangedEvent
11. **Command**: PlayBassReference
12. **Event**: BassReferencePlayingEvent

### Badge Award Flow

1. **Command**: CheckPracticeStreak
2. **Event**: PracticeStreakUpdatedEvent
3. **Command**: EvaluateStreakBadges
4. **Event**: BadgeCriteriaEvaluatedEvent
5. **Command**: CheckExerciseCompletion
6. **Event**: ExerciseCompletionCheckedEvent
7. **Command**: EvaluateCompletionBadges
8. **Event**: BadgeCriteriaEvaluatedEvent
9. **Command**: AwardBadge
10. **Event**: BadgeAwardedEvent
11. **Command**: NotifyUser
12. **Event**: UserNotifiedEvent

### Visualization Components Flow

1. **Command**: InitializeVisualization
2. **Event**: VisualizationInitializedEvent
3. **Command**: LoadNotationData
4. **Event**: NotationDataLoadedEvent
5. **Command**: LoadFretboardData
6. **Event**: FretboardDataLoadedEvent
7. **Command**: SyncWithPlayback
8. **Event**: VisualizationSyncedEvent
9. **Command**: HandleUserInteraction
10. **Event**: VisualizationInteractionEvent
11. **Command**: UpdateDisplay
12. **Event**: DisplayUpdatedEvent
13. **Command**: SaveVisualizationConfig
14. **Event**: ConfigurationSavedEvent

## MVP Requirements and Boundaries

Based on our systematic brainstorming, the following MVP requirements and boundaries have been established:

### Content Context (MVP)

- Metadata will be gathered by n8n and sent to Supabase in real-time
- Flexible tagging system without predefined taxonomy
- Two types of mistakes will be tracked:
  1. Player technique mistakes to avoid
  2. Factual/instructional mistakes in the original tutorials (fact-checking)

### Widget Context (MVP)

- YouTube Exerciser Widget will display:
  - YouTube video embed
  - Tutorial summary, skill level, and genre alongside the video
  - Exercise list displayed as cards (showing exercise names)
  - Timestamp markers for navigating the video
- Users will have full control to adjust all widget settings
- EDIT button for each widget to override incorrect settings due to poor video quality

### Learning Context (MVP)

- Generation Token system with free tokens upon signup and paid model for additional tokens
- Minimal learning hierarchy implementation (full mission system comes after MVP)
- No gamification features (XP, achievements, streaks) in the MVP

### User Context (MVP)

- Minimal user information collection
- User settings saved in Supabase when editing widgets
- User profile showing previously analyzed tutorials and their settings
- Token balance display and purchase functionality

### Playback Context (MVP)

- MP3 support prioritizing low file weight
- Tempo control in 1 BPM increments
- Pitch transposition range from -12 to +12 semitones
- Metronome with time signatures, accent patterns, sound selection, visual metronome, subdivision, and volume controls
- Predefined loops based on exercise boundaries (2 or 4 bars)
- Separate controls for drums, bass, harmony, and metronome

### Analysis Context (MVP)

- Extract short summary, tags, and headline from YouTube videos
- Deliver approximate results with error messages when analysis is incomplete
- Cache extracted data in Supabase for future users
- Periodic script to check for updates to original YouTube videos (future enhancement)

### Social Context (Post-MVP)

- Comments under YouTube Exerciser Widget
- Suggestion of popular settings from other users
- Rating system for tutorials and settings
- Teacher (AI) and student relationship features

### Shared UI Context (MVP)

- Sheet Player and Fretboard Visualizer as core shared components
- Real-time playback synchronization with audio engine
- Support for standard notation, tablature, and chord symbols
- Interactive fretboard display with configurable string/fret count
- Theme support (dark/light mode) and lefty/righty options
- Basic zoom and scroll functionality
- Performance optimization for smooth rendering

## Metadata Requirements

Based on the provided metadata specification, the following fields will be supported:

### Basic Info

- `lesson_id` / `exercise_id`
- `title`
- `short_description`
- `full_description`
- `objectives`
- `author`
- `date_created`, `last_updated`

### Content & Structure

- `type` (lesson, groove, theory, drill, challenge, mistake, etc.)
- `blocks`
- `level` (beginner, intermediate, advanced)
- `duration`

### Exercise Details

- `fingering`
- `positions`
- `micro_shift` / `shift`
- `notation`
- `audio_url`
- `video_url`
- `svg_fretboard` / `visualization_data`
- `backing_track_url`

### Tagging & Metadata

- `difficulty`
- `techniques`
- `skills_targeted`
- `depth`
- `theory_tags`
- `mistake_tags`
- `prerequisites`
- `related_lessons`
- `recommended_next_steps`

### Gamification & Progress (Post-MVP)

- `xp_value`
- `achievements`
- `streak_bonus`

### Social & Community (Post-MVP)

- `instagram_caption`
- `comments_enabled`
- `likes_count`, `comments_count`

### Platform-specific

- `platform`
- `is_published`, `is_draft`, `admin_review_required`
- `visibility`
- `translations`

## Implementation Guidelines

### YouTube Exerciser Widget Implementation

```typescript
// Example: YouTube Exerciser Widget
// src/domains/widgets/aggregates/youtubeExerciser/YouTubeExerciserWidget.ts

import { Entity } from '@/shared/domain/Entity';
import { ExerciseList } from './ExerciseList';
import { VideoEmbed } from './VideoEmbed';
import { TimestampMarker } from './valueObjects/TimestampMarker';
import { YouTubeUrl } from './valueObjects/YouTubeUrl';
import { ExerciseSelectedEvent } from '../../events/ExerciseSelectedEvent';
import { DomainEventPublisher } from '@/shared/events/DomainEventPublisher';
import { N8nService } from '@/infrastructure/api/n8n/N8nService';
import { GenerationTokenService } from '@/domains/learning/services/GenerationTokenService';
import { PlaybackEngineService } from '@/domains/playback/services/PlaybackEngineService';

export class YouTubeExerciserWidget extends Entity {
  private readonly _title: string;
  private readonly _description: string;
  private readonly _n8nService: N8nService;
  private readonly _tokenService: GenerationTokenService;
  private readonly _playbackService: PlaybackEngineService;
  private _videoEmbed: VideoEmbed | null;
  private _exerciseList: ExerciseList | null;
  private _selectedExerciseId: string | null;
  private _timestampMarkers: TimestampMarker[];
  private _tutorialSummary: string | null;
  private _skillLevel: string | null;
  private _genre: string | null;

  constructor(props: {
    id: string;
    title: string;
    description: string;
    n8nService: N8nService;
    tokenService: GenerationTokenService;
    playbackService: PlaybackEngineService;
  }) {
    super(props.id);
    this._title = props.title;
    this._description = props.description;
    this._n8nService = props.n8nService;
    this._tokenService = props.tokenService;
    this._playbackService = props.playbackService;
    this._videoEmbed = null;
    this._exerciseList = null;
    this._selectedExerciseId = null;
    this._timestampMarkers = [];
    this._tutorialSummary = null;
    this._skillLevel = null;
    this._genre = null;
  }

  // Process YouTube URL
  async processYouTubeUrl(urlString: string, userId: string): Promise<boolean> {
    // Validate URL
    const videoUrl = new YouTubeUrl(urlString);

    // Check if video has already been analyzed
    const existingData = await this.checkExistingAnalysis(videoUrl.value);
    if (existingData) {
      this.applyExistingAnalysis(existingData);
      return true;
    }

    // Check if user has available tokens
    const hasToken = await this._tokenService.checkTokenAvailability(userId);
    if (!hasToken) {
      throw new Error('No generation tokens available');
    }

    // Consume token
    await this._tokenService.consumeToken(userId);

    // Create video embed
    this._videoEmbed = new VideoEmbed({
      id: crypto.randomUUID(),
      videoUrl: videoUrl.value,
      width: 640,
      height: 360,
    });

    // Trigger n8n workflow for extraction
    const extractionResult = await this._n8nService.triggerWorkflow(
      'youtube-extraction',
      {
        videoUrl: videoUrl.value,
        userId,
      },
    );

    // Process extraction results
    if (extractionResult.success) {
      // Set tutorial summary, skill level, and genre
      this._tutorialSummary = extractionResult.summary;
      this._skillLevel = extractionResult.skillLevel;
      this._genre = extractionResult.genre;

      // Create exercise list
      this._exerciseList = new ExerciseList({
        id: crypto.randomUUID(),
        exercises: extractionResult.exercises,
      });

      // Create timestamp markers
      this._timestampMarkers = extractionResult.exercises.map(
        (exercise) =>
          new TimestampMarker({
            time: exercise.startTime,
            label: exercise.title,
            exerciseId: exercise.id,
          }),
      );

      // Save analysis to Supabase for future use
      await this.saveAnalysisToSupabase(videoUrl.value, extractionResult);

      return true;
    }

    return false;
  }

  // Check if video has already been analyzed
  private async checkExistingAnalysis(videoUrl: string): Promise<any> {
    // Implementation to check Supabase for existing analysis
    return null; // Placeholder
  }

  // Apply existing analysis data
  private applyExistingAnalysis(data: any): void {
    // Implementation to apply existing analysis data
  }

  // Save analysis to Supabase
  private async saveAnalysisToSupabase(
    videoUrl: string,
    data: any,
  ): Promise<void> {
    // Implementation to save analysis to Supabase
  }

  // Select exercise
  selectExercise(exerciseId: string): void {
    if (!this._exerciseList) {
      throw new Error('No exercise list available');
    }

    // Find exercise
    const exercise = this._exerciseList.findExercise(exerciseId);
    if (!exercise) {
      throw new Error(`Exercise ${exerciseId} not found`);
    }

    // Set selected exercise
    this._selectedExerciseId = exerciseId;

    // Jump to timestamp in video
    if (this._videoEmbed) {
      const marker = this._timestampMarkers.find(
        (m) => m.exerciseId === exerciseId,
      );
      if (marker) {
        this._videoEmbed.seekTo(marker.time);
      }
    }

    // Configure playback engine
    this._playbackService.configurePlayback({
      tempo: exercise.tempo,
      metronomeEnabled: true,
      drummerLoopEnabled: exercise.hasDrummerLoop,
      referenceEnabled: exercise.hasReference,
    });

    // Publish domain event
    DomainEventPublisher.publish(
      new ExerciseSelectedEvent({
        widgetId: this.id,
        exerciseId,
        configuration: {
          tempo: exercise.tempo,
          difficulty: exercise.difficulty,
          technique: exercise.technique,
        },
      }),
    );
  }

  // Getters
  get title(): string {
    return this._title;
  }
  get description(): string {
    return this._description;
  }
  get videoEmbed(): VideoEmbed | null {
    return this._videoEmbed;
  }
  get exerciseList(): ExerciseList | null {
    return this._exerciseList;
  }
  get selectedExerciseId(): string | null {
    return this._selectedExerciseId;
  }
  get timestampMarkers(): readonly TimestampMarker[] {
    return [...this._timestampMarkers];
  }
  get tutorialSummary(): string | null {
    return this._tutorialSummary;
  }
  get skillLevel(): string | null {
    return this._skillLevel;
  }
  get genre(): string | null {
    return this._genre;
  }
}
```

### Generation Token Implementation

```typescript
// Example: Generation Token
// src/domains/learning/aggregates/generationToken/GenerationToken.ts

import { Entity } from '@/shared/domain/Entity';
import { TokenType } from './valueObjects/TokenType';
import { TokenStatus } from './valueObjects/TokenStatus';
import { TokenConsumedEvent } from '../../events/TokenConsumedEvent';
import { DomainEventPublisher } from '@/shared/events/DomainEventPublisher';

export class GenerationToken extends Entity {
  private readonly _userId: string;
  private readonly _type: TokenType;
  private _status: TokenStatus;
  private readonly _createdAt: Date;
  private _consumedAt: Date | null;

  constructor(props: {
    id: string;
    userId: string;
    type: TokenType;
    createdAt: Date;
  }) {
    super(props.id);
    this._userId = props.userId;
    this._type = props.type;
    this._status = TokenStatus.AVAILABLE;
    this._createdAt = props.createdAt;
    this._consumedAt = null;
  }

  // Getters
  get userId(): string {
    return this._userId;
  }
  get type(): TokenType {
    return this._type;
  }
  get status(): TokenStatus {
    return this._status;
  }
  get createdAt(): Date {
    return this._createdAt;
  }
  get consumedAt(): Date | null {
    return this._consumedAt;
  }

  // Check if token is available
  isAvailable(): boolean {
    return this._status === TokenStatus.AVAILABLE;
  }

  // Consume token
  consume(): void {
    if (!this.isAvailable()) {
      throw new Error('Token is not available');
    }

    this._status = TokenStatus.CONSUMED;
    this._consumedAt = new Date();

    // Publish domain event
    DomainEventPublisher.publish(
      new TokenConsumedEvent({
        tokenId: this.id,
        userId: this._userId,
        consumedAt: this._consumedAt,
      }),
    );
  }
}
```

### Playback Engine Implementation

```typescript
// Example: Playback Engine
// src/domains/playback/aggregates/playbackEngine/PlaybackEngine.ts

import { Entity } from '@/shared/domain/Entity';
import { Tempo, Pitch, Volume } from './valueObjects';
import { MetronomeSettings } from '../metronome/MetronomeSettings';
import { AudioTrack } from '../audioTrack/AudioTrack';
import { TempoChangedEvent } from '../../events/TempoChangedEvent';
import { DomainEventPublisher } from '@/shared/events/DomainEventPublisher';

export class PlaybackEngine extends Entity {
  private _tempo: Tempo;
  private _pitch: Pitch;
  private _volume: Volume;
  private _metronomeSettings: MetronomeSettings;
  private _drummerLoop: AudioTrack | null;
  private _bassReference: AudioTrack | null;
  private _isPlaying: boolean;

  constructor(props: {
    id: string;
    initialTempo?: number;
    initialPitch?: number;
    initialVolume?: number;
  }) {
    super(props.id);
    this._tempo = new Tempo(props.initialTempo || 120);
    this._pitch = new Pitch(props.initialPitch || 0);
    this._volume = new Volume(props.initialVolume || 80);
    this._metronomeSettings = new MetronomeSettings({
      enabled: false,
      accentFirstBeat: true,
      beatsPerMeasure: 4,
      subdivision: 1,
      soundSelection: 'click',
      volume: 80,
    });
    this._drummerLoop = null;
    this._bassReference = null;
    this._isPlaying = false;
  }

  // Getters
  get tempo(): number {
    return this._tempo.value;
  }
  get pitch(): number {
    return this._pitch.value;
  }
  get volume(): number {
    return this._volume.value;
  }
  get isPlaying(): boolean {
    return this._isPlaying;
  }

  // Playback controls
  play(): void {
    if (this._isPlaying) return;
    this._isPlaying = true;

    // Start metronome if enabled
    if (this._metronomeSettings.enabled) {
      this.startMetronome();
    }

    // Play drummer loop if available
    if (this._drummerLoop) {
      this._drummerLoop.play(this._tempo.value, this._volume.value);
    }

    // Play bass reference if available
    if (this._bassReference) {
      this._bassReference.play(
        this._tempo.value,
        this._pitch.value,
        this._volume.value,
      );
    }
  }

  pause(): void {
    if (!this._isPlaying) return;
    this._isPlaying = false;

    // Stop all audio
    this.stopMetronome();

    if (this._drummerLoop) {
      this._drummerLoop.pause();
    }

    if (this._bassReference) {
      this._bassReference.pause();
    }
  }

  // Tempo control (1 BPM increments)
  adjustTempo(newTempo: number): void {
    const oldTempo = this._tempo.value;
    this._tempo = new Tempo(newTempo);

    // Update playback speed if playing
    if (this._isPlaying) {
      if (this._metronomeSettings.enabled) {
        this.updateMetronomeTempo(newTempo);
      }

      if (this._drummerLoop) {
        this._drummerLoop.setTempo(newTempo);
      }

      if (this._bassReference) {
        this._bassReference.setTempo(newTempo);
      }
    }

    // Publish domain event
    DomainEventPublisher.publish(
      new TempoChangedEvent({
        engineId: this.id,
        oldTempo: oldTempo,
        newTempo: newTempo,
      }),
    );
  }

  // Pitch control (transposition -12 to +12 semitones)
  adjustPitch(newPitch: number): void {
    if (newPitch < -12 || newPitch > 12) {
      throw new Error('Pitch must be between -12 and +12 semitones');
    }

    this._pitch = new Pitch(newPitch);

    // Update pitch if playing
    if (this._isPlaying && this._bassReference) {
      this._bassReference.setPitch(newPitch);
    }
  }

  // Metronome controls
  startMetronome(): void {
    // Implementation details
  }

  stopMetronome(): void {
    // Implementation details
  }

  updateMetronomeTempo(tempo: number): void {
    // Implementation details
  }

  configureMetronome(settings: Partial<MetronomeSettings>): void {
    this._metronomeSettings = new MetronomeSettings({
      ...this._metronomeSettings,
      ...settings,
    });
  }

  // Loop controls
  setLoopLength(bars: number): void {
    if (bars !== 2 && bars !== 4) {
      throw new Error('Loop length must be 2 or 4 bars for MVP');
    }

    // Implementation details for setting loop length
  }

  // Audio track management
  setDrummerLoop(audioTrack: AudioTrack | null): void {
    if (this._drummerLoop && this._isPlaying) {
      this._drummerLoop.stop();
    }

    this._drummerLoop = audioTrack;

    if (this._drummerLoop && this._isPlaying) {
      this._drummerLoop.play(this._tempo.value, this._volume.value);
    }
  }

  setBassReference(audioTrack: AudioTrack | null): void {
    if (this._bassReference && this._isPlaying) {
      this._bassReference.stop();
    }

    this._bassReference = audioTrack;

    if (this._bassReference && this._isPlaying) {
      this._bassReference.play(
        this._tempo.value,
        this._pitch.value,
        this._volume.value,
      );
    }
  }
}
```

## Future Audio Recording Implementation

While not part of the MVP, the future audio recording functionality will be implemented as follows:

```typescript
// Example: Recording Widget (Future Implementation)
// src/domains/widgets/aggregates/recordingWidget/RecordingWidget.ts

import { Entity } from '@/shared/domain/Entity';
import { AudioRecording } from './AudioRecording';
import { WaveformDisplay } from './WaveformDisplay';
import { RecordingCompletedEvent } from '../../events/RecordingCompletedEvent';
import { DomainEventPublisher } from '@/shared/events/DomainEventPublisher';

export class RecordingWidget extends Entity {
  private readonly _title: string;
  private readonly _description: string;
  private _isRecording: boolean;
  private _currentRecording: AudioRecording | null;
  private _waveformDisplay: WaveformDisplay;

  constructor(props: { id: string; title: string; description: string }) {
    super(props.id);
    this._title = props.title;
    this._description = props.description;
    this._isRecording = false;
    this._currentRecording = null;
    this._waveformDisplay = new WaveformDisplay({
      id: crypto.randomUUID(),
      width: 600,
      height: 200,
      data: [],
    });
  }

  // Getters
  get title(): string {
    return this._title;
  }
  get description(): string {
    return this._description;
  }
  get isRecording(): boolean {
    return this._isRecording;
  }
  get currentRecording(): AudioRecording | null {
    return this._currentRecording;
  }
  get waveformDisplay(): WaveformDisplay {
    return this._waveformDisplay;
  }

  // Start recording
  startRecording(): void {
    if (this._isRecording) return;

    this._isRecording = true;
    this._currentRecording = new AudioRecording({
      id: crypto.randomUUID(),
      startTime: new Date(),
      format: 'wav',
    });

    // Clear waveform display
    this._waveformDisplay.clearData();
  }

  // Stop recording
  stopRecording(): AudioRecording | null {
    if (!this._isRecording || !this._currentRecording) return null;

    this._isRecording = false;
    this._currentRecording.complete(new Date());

    const recording = this._currentRecording;

    // Publish domain event
    DomainEventPublisher.publish(
      new RecordingCompletedEvent({
        widgetId: this.id,
        recordingId: recording.id,
        duration: recording.duration,
      }),
    );

    return recording;
  }

  // Update waveform display with real-time audio data
  updateWaveform(audioData: number[]): void {
    if (!this._isRecording) return;

    this._waveformDisplay.appendData(audioData);
  }

  // Save recording
  saveRecording(): string | null {
    if (this._isRecording || !this._currentRecording) return null;

    // Implementation details for saving recording
    return this._currentRecording.id;
  }
}
```

## Conclusion

This comprehensive Domain-Driven Design strategy provides a solid foundation for the BassNotion platform. By implementing both strategic patterns (bounded contexts, context mapping, ubiquitous language) and tactical patterns (aggregates, entities, value objects, domain services), the platform can maintain clear boundaries while enabling complex domain logic.

The strategy correctly reflects the learning hierarchy (Main Story Arcs > Main Quests > Stages > Missions > Tasks) and positions the YouTube Exerciser Widget as a key component that processes YouTube links, displays extracted exercises with timestamps, and configures other widgets based on selected exercises. The Bass Drills Widget serves as the main composite widget that integrates other widgets into a unified practice experience.

The Playback Engine is recognized as a critical component that provides audio playback capabilities across the platform, including metronome, drummer loops, and reference MIDI basslines with tempo and pitch control. The Generation Token system manages the consumption of YouTube link processing units, while the Badge system rewards users for practice streaks, exercise scores, and other achievements.

The MVP boundaries are clearly defined, focusing on the YouTube Exerciser Widget as the initial revenue driver, with a clear path to expanding into the full mission-based platform in the future. The metadata requirements are comprehensive and aligned with the platform's needs, ensuring that the system can scale and evolve over time.

By following this DDD strategy, the BassNotion platform will be well-positioned for future growth and evolution, with a codebase that accurately reflects the domain model and business requirements.
