# React Query Integration Guide

## Overview

React Query (TanStack Query) has been added to the BassNotion tech stack as a powerful complement to Zustand for managing server state. This integration provides a clear separation of concerns:

- **Zustand**: Client-side state, UI state, temporary form data
- **React Query**: Server state, API calls, caching, synchronization

## Architecture

### State Management Strategy

```
┌─────────────────┐    ┌─────────────────┐
│     Zustand     │    │  React Query    │
│                 │    │                 │
│ • UI State      │    │ • Server Data   │
│ • Form Data     │    │ • API Calls     │
│ • User Prefs    │    │ • Caching       │
│ • Modal State   │    │ • Background    │
│ • Navigation    │    │   Updates       │
└─────────────────┘    └─────────────────┘
```

## Setup

### 1. Provider Configuration

The React Query provider is configured in `/apps/frontend/src/lib/react-query.tsx`:

```tsx
export function ReactQueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            retry: (failureCount, error) => {
              // Don't retry on 4xx errors
              if (error instanceof Error && 'status' in error) {
                const status = (error as any).status;
                if (status >= 400 && status < 500) {
                  return false;
                }
              }
              return failureCount < 3;
            },
          },
          mutations: {
            retry: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### 2. API Client

A robust API client is provided in `/apps/frontend/src/lib/api-client.ts`:

```tsx
import { apiClient } from '@/lib/api-client';

// GET request
const user = await apiClient.get<User>('/api/users/123');

// POST request
const newUser = await apiClient.post<User>('/api/users', userData);

// Authentication
apiClient.setAuthToken(token);
apiClient.clearAuthToken();
```

## Usage Patterns

### 1. Basic Query Hook

```tsx
import { useUser } from '@/lib/hooks/use-api';

function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useUser(userId);
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>Hello, {user.displayName}!</div>;
}
```

### 2. Mutation Hook

```tsx
import { useUpdateUserProfile } from '@/lib/hooks/use-api';

function EditProfile({ userId }: { userId: string }) {
  const updateProfile = useUpdateUserProfile();
  
  const handleSave = async (data: Partial<UserProfile>) => {
    try {
      await updateProfile.mutateAsync({ userId, data });
      // Success handled automatically
    } catch (error) {
      // Error handling
    }
  };
  
  return (
    <button 
      onClick={() => handleSave({ bio: 'New bio' })}
      disabled={updateProfile.isPending}
    >
      {updateProfile.isPending ? 'Saving...' : 'Save'}
    </button>
  );
}
```

### 3. Combined with Zustand

```tsx
import { useUser, useUpdateUserProfile } from '@/lib/hooks/use-api';
import { useUserUIStore } from '@/shared/stores/user-store';

function UserDashboard({ userId }: { userId: string }) {
  // Server state (React Query)
  const { data: user, isLoading } = useUser(userId);
  const updateProfile = useUpdateUserProfile();
  
  // Client state (Zustand)
  const {
    isProfileModalOpen,
    profileFormData,
    openProfileModal,
    closeProfileModal,
    setProfileFormData,
  } = useUserUIStore();
  
  const handleSave = async () => {
    if (!profileFormData) return;
    
    await updateProfile.mutateAsync({
      userId,
      data: profileFormData,
    });
    
    closeProfileModal(); // Update UI state
  };
  
  return (
    <div>
      <h1>{user?.displayName}</h1>
      <button onClick={openProfileModal}>Edit Profile</button>
      
      {isProfileModalOpen && (
        <ProfileModal
          onSave={handleSave}
          onClose={closeProfileModal}
          isLoading={updateProfile.isPending}
        />
      )}
    </div>
  );
}
```

## Query Key Management

Centralized query keys ensure consistency and easy invalidation:

```tsx
export const queryKeys = {
  users: ['users'] as const,
  user: (id: string) => ['users', id] as const,
  userProfile: (id: string) => ['users', id, 'profile'] as const,
  exercises: ['exercises'] as const,
  exercise: (id: string) => ['exercises', id] as const,
} as const;
```

## Advanced Patterns

### 1. Optimistic Updates

```tsx
export function useOptimisticUpdate<T>(
  queryKey: readonly unknown[],
  mutationFn: (data: T) => Promise<T>
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn,
    onMutate: async (newData) => {
      await queryClient.cancelQueries({ queryKey });
      const previousData = queryClient.getQueryData(queryKey);
      queryClient.setQueryData(queryKey, newData);
      return { previousData };
    },
    onError: (err, newData, context) => {
      if (context?.previousData) {
        queryClient.setQueryData(queryKey, context.previousData);
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });
}
```

### 2. Background Synchronization

React Query automatically:
- Refetches data when the window regains focus
- Retries failed requests with exponential backoff
- Deduplicates identical requests
- Provides stale-while-revalidate caching

### 3. Error Handling

```tsx
function UserProfile({ userId }: { userId: string }) {
  const { data: user, error, isError } = useUser(userId);
  
  if (isError) {
    if (error instanceof ApiError) {
      if (error.status === 404) {
        return <div>User not found</div>;
      }
      if (error.status >= 500) {
        return <div>Server error. Please try again later.</div>;
      }
    }
    return <div>Something went wrong</div>;
  }
  
  return <div>{user?.displayName}</div>;
}
```

## Best Practices

### 1. State Separation

- **Use Zustand for**: UI state, form state, user preferences, navigation state
- **Use React Query for**: API data, server state, background updates

### 2. Query Keys

- Use consistent, hierarchical query keys
- Include all variables that affect the query in the key
- Use the centralized `queryKeys` object

### 3. Error Handling

- Handle different error types appropriately
- Use the `ApiError` class for structured error handling
- Provide meaningful user feedback

### 4. Loading States

- Always handle loading states in your UI
- Use skeleton loaders for better UX
- Consider optimistic updates for immediate feedback

### 5. Cache Management

- Use appropriate `staleTime` values
- Invalidate related queries after mutations
- Use `setQueryData` for optimistic updates

## Development Tools

### React Query Devtools

The devtools are automatically included in development mode:

```tsx
<ReactQueryDevtools initialIsOpen={false} />
```

Access them by clicking the React Query icon in your browser.

### Zustand Devtools

Zustand stores are configured with devtools:

```tsx
export const useUserUIStore = create<UserUIState>()(
  devtools(
    (set) => ({
      // store implementation
    }),
    {
      name: 'user-ui-store',
    }
  )
);
```

## Migration Guide

### From Pure Zustand

If you have existing Zustand stores managing server data:

1. **Identify server state**: Data that comes from APIs
2. **Create React Query hooks**: Replace server state with query/mutation hooks
3. **Keep client state**: UI state remains in Zustand
4. **Update components**: Use both hooks in components

### Example Migration

**Before (Zustand only):**
```tsx
const useUserStore = create((set) => ({
  user: null,
  isLoading: false,
  fetchUser: async (id) => {
    set({ isLoading: true });
    const user = await api.getUser(id);
    set({ user, isLoading: false });
  },
}));
```

**After (React Query + Zustand):**
```tsx
// React Query for server state
const { data: user, isLoading } = useUser(userId);

// Zustand for UI state
const useUserUIStore = create((set) => ({
  isProfileModalOpen: false,
  openProfileModal: () => set({ isProfileModalOpen: true }),
}));
```

## Conclusion

This integration provides a robust, scalable solution for state management in the BassNotion application. React Query handles all the complexity of server state management, while Zustand provides a simple, fast solution for client-side state.

The combination offers:
- **Better performance**: Automatic caching and background updates
- **Better UX**: Optimistic updates and smart retries
- **Better DX**: Powerful devtools and clear separation of concerns
- **Better maintainability**: Centralized API logic and consistent patterns 